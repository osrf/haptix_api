/*
   HAPTIX User API, Part 2

   This file defines data structures and API functions
   available only in simulation.
*/

#pragma once

#include "haptix.h"

// ---------- data structures ----------

/// \brief Simulation information
struct _hxSimInfo
{
  /// \brief Number of models in simulation.
  /// This defines the range of elements in the "models" array.
  int modelCount;

  /// \brief Array of models in simulation.
  /// \sa modelCount
  hxModel **models;
};

/// \brief Information about a model
struct _hxModel
{
  /// \brief True if the model is static (immovable).
  bool isStatic;

  /// \brief Unique id of the model. This number is generated by simulation.
  int id;

  /// \brief Number of links in the model.
  /// This defines the range of elements in the "links" array.
  int linkCount;

  /// \brief Array of links in the model.
  /// \sa linkCount
  hxLink **links;

  /// \brief Number of joints in the model.
  /// This defines the range of elements in the "joints" array.
  int linkCount;

  /// \brief Array of joints in the model.
  /// \sa jointCount
  hxJoint **joints;
};

/// \brief Information about a link. A link is a component of a model
struct _hxLink
{
  /// \brief Position, a 3-vector where each component is in meters
  float pos[3];

  /// \brief Orientation, a quaternion
  float quat[4];

  /// \brief Linear velocity (m/s)
  float linvel[3];

  /// \brief Angular velocity (rad/s)
  float angvel[3];

  /// \brief Linear acceleration (m/s/s)
  float linacc[3];

  /// \brief Angular acceleration (rad/s/s)
  float angacc[3];
};

/// \brief information about a joint. A joint is a component of a model
struct _hxJoint
{
  /// \brief Position (radians)
  float pos;

  /// \brief Velocity (rad/s)
  float vel;

  /// \brief acceleration (rad/s/s)
  float acc;

  /// \brief Torque due to actuation (N-m)
  float torque_motor;

  /// \brief torque due to limits, damping, friction (N-m)
  float torque_passive;
};

/// \brief Information about contacts
struct _hxContact
{
  /// \brief Number of currently active contacts
  int contactCount;

  /// \brief contact descriptor for contacting body 1
  int body1[hxMAXCONTACT];

  /// \brief contact descriptor for contacting body 2
  int body2[hxMAXCONTACT];

  /// \brief Description of contact frame relative to global frame:
  /// origin of frame
  float point[hxMAXCONTACT][3];

  /// \brief Description of contact frame relative to global frame:
  /// normal direction (unit vector)
  float normal[hxMAXCONTACT][3];

  /// \brief Description of contact frame relative to global frame:
  /// first tangent direction (unit vector)
  float tangent1[hxMAXCONTACT][3];

  /// \brief Description of contact frame relative to global frame:
  /// second tangent direction (unit vector)
  float tangent2[hxMAXCONTACT][3];

  /// \brief Normal distance (penetration depth) in contact frame (m).
  float distance[hxMAXCONTACT];

  /// \brief Relative velocity in contact frame (m/s),
  /// with axis order (normal, tangent1, tangent2)
  float velocity[hxMAXCONTACT][3];

  /// \brief Contact force in contact frame (N),
  /// with axis order (normal, tangent1, tangent2)
  float force[hxMAXCONTACT][3];
};

/// \def hxSimInfo
/// \brief Information about the simulation world.
typedef struct _hxSimInfo hxSimInfo;

/// \def hxModel
/// \brief Information about simulated models.
typedef struct _hxModel hxBody;

/// \def hxLink
/// \brief Information about a link.
typedef struct _hxLink hxLink;

/// \def hxJoint
/// \brief Information about a joint.
typedef struct _hxJoint hxJoint;

/// \def hxContact
/// \brief Information about contacts.
typedef struct _hxContact hxContact;

// ---------- API functions ----------

/// \brief Get simulation information.
/// \param[in] _target Device to be connected.
/// The valid targets are defined in #hxTarget.
/// \param[out] _siminfo Simulation information requested.
/// \sa _hxSimInfo
/// \return 'hxOK' if the function succeed or an error code otherwise.
hxResult hxs_siminfo(int _target, hxSimInfo *_siminfo);

/// \brief Get information about active contacts
/// \param[in] _target Device to be connected. The valid targets are defined in
/// #hxTarget.
/// \return 'hxOK' if the function succeed or an error code otherwise.
hxResult hxs_getcontact(int _target, hxContact *_contact);

/// \brief Get Jacobian of global point attached to robot link
/// (index between 1 and njoint-1) size of Jacobian matrix is
/// 3-by-njoint, in row-major format.
/// \param[in] _target Device to be connected. The valid targets are defined in
/// #hxTarget.
/// \param[in] _link Model link.
/// \param[in] _point Point on the link.
/// \param[out] _jacobian Resulting jacobian matrix.
/// \return 'hxOK' if the function succeed or an error code otherwise.
hxResult hxs_getjacobian(int _target, const hxLink *_link,
                         const float *_point, float *_jacobian);

/// \brief Set simulation state (position and velocity) as follows:
///   the robot base and objects are set from hxModel
///   the robot links are set from hxJoint via forward kinematics
///   the robot link data in hxBody, and all acceleration and torque
///   data are ignored.
/// \param[in] _target Device to be connected. The valid targets are defined in
/// #hxTarget.
/// \param[in] _model Model information to set.
/// \param[in] _joint Joint information to set.
/// \return 'hxOK' if the function succeed or an error code otherwise.
hxResult hxs_setstate(int _target, const hxModel *_model,
                      const hxJoint *_joint);

/// \brief Add model during runtime.
/// \param[in] _urdf URDF xml description of the model.
/// \param[in] _x X position in global frame (m)
/// \param[in] _y Y position in global frame (m)
/// \param[in] _z Z position in global frame (m)
/// \param[in] _roll Roll in global frame (radians)
/// \param[in] _pitch Pitch in global frame (radians)
/// \param[in] _yaw Yaw in global frame (radians)
/// \return Pointer to the new model.
hxModel *hxs_add_model(const char *_urdf, float _x, float _y, float _z,
                       float _roll, float _pitch, float _yaw);

/// \brief Remove model.
/// \param[in] _id Id of the model.
/// \return 'hxOK' if the function succeed or an error code otherwise.
hxResult hxs_remove_model(int _id);

/// \brief Remove model.
/// \param[in] _model Pointer to the model.
/// \return 'hxOK' if the function succeed or an error code otherwise.
hxResult hxs_remove_model(const hxModel *_model);

/// \brief Set model pose.
/// \param[in] _id Id of the model.
/// \param[in] _x X position in global frame (m)
/// \param[in] _y Y position in global frame (m)
/// \param[in] _z Z position in global frame (m)
/// \param[in] _roll Roll in global frame (radians)
/// \param[in] _pitch Pitch in global frame (radians)
/// \param[in] _yaw Yaw in global frame (radians)
/// \return 'hxOK' if the function succeed or an error code otherwise.
hxResult hxs_pose(int _id, float _x, float _y, float _z,
                  float _roll, float _pitch, float _yaw);

/// \brief Set the linear velocity of a model.
/// \param[in] _id Id of the model.
/// \param[in] _vx X velocity (m/s)
/// \param[in] _vy Y velocity (m/s)
/// \param[in] _vz Z velocity (m/s)
/// \return 'hxOK' if the function succeed or an error code otherwise.
hxResult hxs_linear_velocity(int _id, float _vx, float _vy, float _vz);

/// \brief Set the angular velocity of a model.
/// \param[in] _id Id of the model.
/// \param[in] _vx X velocity (rad/s)
/// \param[in] _vy Y velocity (rad/s)
/// \param[in] _vz Z velocity (rad/s)
/// \return 'hxOK' if the function succeed or an error code otherwise.
hxResult hxs_angular_velocity(int _id, float _vx, float _vy, float _vz);

/// \brief Set the linear acceleration on a model.
/// \param[in] _id Id of the model.
/// \param[in] _ax X acceleration (m/s/s)
/// \param[in] _ay Y acceleration (m/s/s)
/// \param[in] _az Z acceleration (m/s/s)
/// \return 'hxOK' if the function succeed or an error code otherwise.
hxResult hxs_linear_accel(int _id, float _ax, float _ay, float _az);

/// \brief Set the angular acceleration on a model.
/// \param[in] _id Id of the model.
/// \param[in] _ax X acceleration (rad/s/s)
/// \param[in] _ay Y acceleration (rad/s/s)
/// \param[in] _az Z acceleration (rad/s/s)
/// \return 'hxOK' if the function succeed or an error code otherwise.
hxResult hxs_angular_accel(int _id, float _ax, float _ay, float _az);

/// \brief Apply force to a link.
/// \param[in] _link Pointer to the link.
/// \param[in] _fx X force (N)
/// \param[in] _fy Y force (N)
/// \param[in] _fz Z force (N)
/// \return 'hxOK' if the function succeed or an error code otherwise.
hxResult hxs_force(const hxLink *_link, float _fx, float _fy, float _fz);

/// \brief Apply torque to a link.
/// \param[in] _link Pointer to the link.
/// \param[in] _ax X torque (N-m)
/// \param[in] _ay Y torque (N-m)
/// \param[in] _az Z torque (N-m)
/// \return 'hxOK' if the function succeed or an error code otherwise.
hxResult hxs_torque(const hxLink *_link, float _tx, float _ty, float _tz);

/// \brief Send world reset command/Carry over limb pose between world reset.
/// \param[in] _rsetLimbPose True to reset the post of the limb.
/// \return 'hxOK' if the function succeed or an error code otherwise.
hxResult hxs_reset(bool _resetLimbPose);

/// \brief Reset on-screen timer.
/// \return 'hxOK' if the function succeed or an error code otherwise.
hxResult hxs_reset_timer();

/// \brief Start on-screen timer.
/// \return 'hxOK' if the function succeed or an error code otherwise.
hxResult hxs_start_timer();

/// \brief Stop on-screen timer.
/// \return 'hxOK' if the function succeed or an error code otherwise.
hxResult hxs_stop_timer();

/// \brief Start recording log file. Only one log file may be recorded at
/// a time
/// \param[in] _filename Name of the file to log information into.
/// \return 'hxOK' if the function succeed or an error code otherwise.
hxResult hxs_start_logging(const char *_filename);

/// \brief Determine if logging is running.
/// \return True if logging is running.
bool hxs_is_logging();

/// \brief Stop recording log file.
/// \return 'hxOK' if the function succeed or an error code otherwise.
hxResult hxs_stop_logging();
